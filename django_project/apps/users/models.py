import random
from django.db import models
from django.db.models import Q
from django.contrib.auth.models import AbstractUser, Group
from apps.organization.models import Faculty, Program
from apps.core.managers import RLSManager
from .managers import UserRLSManager

class User(AbstractUser):
    first_name = models.CharField("first name", max_length=30)
    last_name = models.CharField("last name", max_length=30)
    email = models.EmailField("email address", unique=True)
    faculties = models.ManyToManyField(Faculty, blank = True)
    programs = models.ManyToManyField(Program, blank = True)

    objects = UserRLSManager()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
    
    def get_user_rls_filter(self, user):
        return Q(username=user.username)

    def clean(self):
        """
        First, make sure that if it's a new user, we set an unusable password
        Second, make sure the username is autogenerated and unique
        """
        super().clean()
        creation = not self.pk

        if creation:
            self.set_unusable_password()
        
        # check if user exist or not and make the username unique
        self.username = self.first_name + self.last_name
        if creation:
            while User.objects.filter(username=self.username).exists():
                self.username += str(random.randint(0, 9))
        else:
            while User.objects.filter(username=self.username).exclude(pk=self.pk).exists():
                self.username += str(random.randint(0, 9))
        
    def save(self, *args, **kwargs):
        # call the clean here incase we call objects.create and it doesnt clean
        self.clean()
        super().save(*args, **kwargs)
            
    class Meta:
        permissions = [
            ("access_global", "Global Access"),
            ("access_faculty_wide", "Faculty Wide Access"),
            ("access_program_wide", "Program Wide Access"),
        ]

class Student(models.Model):
    user = models.OneToOneField(User, on_delete=models.PROTECT, editable=False)
    _class = models.ForeignKey('academic.Class', on_delete=models.SET_NULL, related_name="students", null=True, blank=True)
    
    objects = RLSManager(field_with_affiliation='_class')
    
    class Meta:
        unique_together = ('_class', 'user')
    
    def __str__(self):
        return self.user.__str__()
    
    def clean(self):
        if hasattr(self, 'user'):
            student_group, _ = Group.objects.get_or_create(name="STUDENT")
            self.user.groups.add(student_group)
    
    def save(self, *args, **kwargs):
        self.clean()
        super().save()
    
    def delete(self, *args, **kwargs):
        """
        if the user is not in any other group, then delete the user
        else, remove the student group from the user
        """
        if self.user.groups.count() == 1:
            # do this to bypass the on_delete protection
            Student._meta.get_field('user').remote_field.on_delete = models.CASCADE
            self.user.delete()
            Student._meta.get_field('user').remote_field.on_delete = models.PROTECT
        else:
            student_group, _ = Group.objects.get_or_create(name="STUDENT")
            self.user.groups.remove(student_group)

        super().delete(*args, **kwargs)
    
    def get_user_rls_filter(self, user):
        """
        the class one is teaching or the user is yourself
        """
        return Q(user=user) | Q(_class__professor=user)